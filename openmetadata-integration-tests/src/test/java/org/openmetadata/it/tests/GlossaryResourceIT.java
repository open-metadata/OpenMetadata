/*
 *  Copyright 2021 Collate
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package org.openmetadata.it.tests;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static org.openmetadata.common.utils.CommonUtil.listOf;
import static org.openmetadata.csv.EntityCsvTest.assertSummary;
import static org.openmetadata.csv.EntityCsvTest.createCsv;

import java.util.List;
import java.util.UUID;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;
import org.openmetadata.csv.CsvUtil;
import org.openmetadata.csv.EntityCsv;
import org.openmetadata.it.util.SdkClients;
import org.openmetadata.it.util.TestNamespace;
import org.openmetadata.schema.api.data.CreateGlossary;
import org.openmetadata.schema.entity.data.Glossary;
import org.openmetadata.schema.type.ApiStatus;
import org.openmetadata.schema.type.EntityHistory;
import org.openmetadata.schema.type.EntityReference;
import org.openmetadata.schema.type.FieldChange;
import org.openmetadata.schema.type.TagLabel;
import org.openmetadata.schema.type.csv.CsvImportResult;
import org.openmetadata.sdk.client.OpenMetadataClient;
import org.openmetadata.sdk.models.ListParams;
import org.openmetadata.sdk.models.ListResponse;
import org.openmetadata.service.jdbi3.GlossaryRepository;

/**
 * Integration tests for Glossary entity operations.
 *
 * <p>Extends BaseEntityIT to inherit all common entity tests. Adds glossary-specific tests for
 * reviewers, mutually exclusive terms, and term hierarchy.
 *
 * <p>Migrated from: org.openmetadata.service.resources.glossary.GlossaryResourceTest
 */
@Execution(ExecutionMode.CONCURRENT)
public class GlossaryResourceIT extends BaseEntityIT<Glossary, CreateGlossary> {

  {
    supportsImportExport = true;
  }

  private Glossary lastCreatedGlossary;

  public GlossaryResourceIT() {
    supportsFollowers = false;
    supportsTags = true;
    supportsDomains = true;
    supportsDataProducts = true;
    supportsSoftDelete = true;
    supportsPatch = true;
    supportsOwners = true;
  }

  @Override
  protected CreateGlossary createMinimalRequest(TestNamespace ns) {
    return new CreateGlossary()
        .withName(ns.prefix("glossary"))
        .withDescription("Test glossary created by integration test");
  }

  @Override
  protected CreateGlossary createRequest(String name, TestNamespace ns) {
    return new CreateGlossary().withName(name).withDescription("Test glossary");
  }

  @Override
  protected Glossary createEntity(CreateGlossary createRequest) {
    return SdkClients.adminClient().glossaries().create(createRequest);
  }

  @Override
  protected Glossary getEntity(String id) {
    return SdkClients.adminClient().glossaries().get(id);
  }

  @Override
  protected Glossary getEntityByName(String fqn) {
    return SdkClients.adminClient().glossaries().getByName(fqn);
  }

  @Override
  protected Glossary patchEntity(String id, Glossary entity) {
    entity.setTermCount(null);
    entity.setUsageCount(null);
    return SdkClients.adminClient().glossaries().update(id, entity);
  }

  @Override
  protected void deleteEntity(String id) {
    SdkClients.adminClient().glossaries().delete(id);
  }

  @Override
  protected void restoreEntity(String id) {
    SdkClients.adminClient().glossaries().restore(id);
  }

  @Override
  protected void hardDeleteEntity(String id) {
    SdkClients.adminClient()
        .glossaries()
        .delete(id, java.util.Map.of("hardDelete", "true", "recursive", "true"));
  }

  @Override
  protected String getEntityType() {
    return "glossary";
  }

  @Override
  protected void validateCreatedEntity(Glossary entity, CreateGlossary createRequest) {
    assertEquals(createRequest.getName(), entity.getName());
    if (createRequest.getDescription() != null) {
      assertEquals(createRequest.getDescription(), entity.getDescription());
    }
    if (createRequest.getMutuallyExclusive() != null) {
      assertEquals(createRequest.getMutuallyExclusive(), entity.getMutuallyExclusive());
    }
  }

  @Override
  protected Glossary getEntityWithFields(String id, String fields) {
    return SdkClients.adminClient().glossaries().get(id, fields);
  }

  @Override
  protected Glossary getEntityByNameWithFields(String fqn, String fields) {
    return SdkClients.adminClient().glossaries().getByName(fqn, fields);
  }

  @Override
  protected Glossary getEntityIncludeDeleted(String id) {
    return SdkClients.adminClient().glossaries().get(id, null, "deleted");
  }

  @Override
  protected ListResponse<Glossary> listEntities(ListParams params) {
    return SdkClients.adminClient().glossaries().list(params);
  }

  // ===================================================================
  // GLOSSARY-SPECIFIC TESTS
  // ===================================================================

  @Test
  void test_createGlossaryWithDisplayName(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("glossaryDisplayName"))
            .withDisplayName("My Custom Glossary")
            .withDescription("Glossary with display name");

    Glossary glossary = createEntity(create);
    assertEquals("My Custom Glossary", glossary.getDisplayName());
  }

  @Test
  void test_createGlossaryMutuallyExclusive(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("glossaryMutuallyExclusive"))
            .withMutuallyExclusive(true)
            .withDescription("Mutually exclusive glossary");

    Glossary glossary = createEntity(create);
    assertTrue(glossary.getMutuallyExclusive());
  }

  @Test
  void test_createGlossaryWithOwner(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    EntityReference ownerRef = testUser1().getEntityReference();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("ownedGlossary"))
            .withOwners(List.of(ownerRef))
            .withDescription("Glossary with owner");

    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "owners");
    assertNotNull(fetched.getOwners());
    assertFalse(fetched.getOwners().isEmpty());
  }

  @Test
  void test_createGlossaryWithReviewers(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    EntityReference reviewerRef = testUser1().getEntityReference();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("reviewedGlossary"))
            .withReviewers(List.of(reviewerRef))
            .withDescription("Glossary with reviewers");

    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "reviewers");
    assertNotNull(fetched.getReviewers());
    assertFalse(fetched.getReviewers().isEmpty());
  }

  @Test
  void test_updateGlossaryDescription(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);

    glossary.setDescription("Updated glossary description");
    Glossary updated = patchEntity(glossary.getId().toString(), glossary);

    assertEquals("Updated glossary description", updated.getDescription());
  }

  @Test
  void test_updateGlossaryDisplayName(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);

    glossary.setDisplayName("My Updated Glossary");
    Glossary updated = patchEntity(glossary.getId().toString(), glossary);

    assertEquals("My Updated Glossary", updated.getDisplayName());
  }

  @Test
  void test_mutuallyExclusiveImmutableAfterCreation(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("immutableMutuallyExclusive"))
            .withMutuallyExclusive(false)
            .withDescription("Glossary with immutable mutuallyExclusive");

    Glossary glossary = createEntity(create);
    assertFalse(glossary.getMutuallyExclusive());

    glossary.setMutuallyExclusive(true);
    Glossary updated = patchEntity(glossary.getId().toString(), glossary);

    assertFalse(updated.getMutuallyExclusive());
  }

  @Test
  void test_addReviewersToGlossary(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "reviewers");
    EntityReference reviewerRef = testUser1().getEntityReference();
    fetched.setReviewers(List.of(reviewerRef));

    Glossary updated = patchEntity(fetched.getId().toString(), fetched);

    Glossary verify = client.glossaries().get(updated.getId().toString(), "reviewers");
    assertNotNull(verify.getReviewers());
    assertTrue(verify.getReviewers().stream().anyMatch(r -> r.getId().equals(reviewerRef.getId())));
  }

  @Test
  void test_softDeleteAndRestoreGlossary(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);
    String glossaryId = glossary.getId().toString();

    deleteEntity(glossaryId);

    assertThrows(
        Exception.class, () -> getEntity(glossaryId), "Deleted glossary should not be retrievable");

    Glossary deleted = getEntityIncludeDeleted(glossaryId);
    assertTrue(deleted.getDeleted());

    restoreEntity(glossaryId);

    Glossary restored = getEntity(glossaryId);
    assertFalse(restored.getDeleted());
  }

  @Test
  void test_hardDeleteGlossary(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);
    String glossaryId = glossary.getId().toString();

    hardDeleteEntity(glossaryId);

    assertThrows(
        Exception.class,
        () -> getEntity(glossaryId),
        "Hard deleted glossary should not be retrievable");
  }

  @Test
  void test_glossaryVersionHistory(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);
    assertEquals(0.1, glossary.getVersion(), 0.001);

    glossary.setDescription("Updated description v1");
    Glossary v2 = patchEntity(glossary.getId().toString(), glossary);
    assertEquals(0.2, v2.getVersion(), 0.001);

    var history = client.glossaries().getVersionList(glossary.getId());
    assertNotNull(history);
    assertNotNull(history.getVersions());
    assertTrue(history.getVersions().size() >= 2);
  }

  @Test
  void test_listGlossaries(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    for (int i = 0; i < 3; i++) {
      CreateGlossary create =
          new CreateGlossary()
              .withName(ns.prefix("listGlossary" + i))
              .withDescription("Glossary for list test");
      createEntity(create);
    }

    ListParams params = new ListParams();
    params.setLimit(100);
    ListResponse<Glossary> response = listEntities(params);

    assertNotNull(response);
    assertNotNull(response.getData());
    assertTrue(response.getData().size() >= 3);
  }

  @Test
  void test_getGlossaryWithReviewersField(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    EntityReference reviewerRef = testUser1().getEntityReference();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("glossaryWithReviewersField"))
            .withReviewers(List.of(reviewerRef))
            .withDescription("Glossary to test reviewers field");

    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "reviewers");
    assertNotNull(fetched.getReviewers());
    assertFalse(fetched.getReviewers().isEmpty());

    for (EntityReference reviewer : fetched.getReviewers()) {
      assertNotNull(reviewer.getId());
      assertNotNull(reviewer.getName());
      assertNotNull(reviewer.getType());
    }
  }

  @Test
  void test_getGlossaryWithOwnersField(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    EntityReference ownerRef = testUser1().getEntityReference();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("glossaryWithOwnersField"))
            .withOwners(List.of(ownerRef))
            .withDescription("Glossary to test owners field");

    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "owners");
    assertNotNull(fetched.getOwners());
    assertFalse(fetched.getOwners().isEmpty());

    for (EntityReference owner : fetched.getOwners()) {
      assertNotNull(owner.getId());
      assertNotNull(owner.getName());
      assertNotNull(owner.getType());
    }
  }

  @Test
  void test_createGlossaryNotMutuallyExclusive(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("glossaryNotMutuallyExclusive"))
            .withMutuallyExclusive(false)
            .withDescription("Not mutually exclusive glossary");

    Glossary glossary = createEntity(create);
    assertFalse(glossary.getMutuallyExclusive());
  }

  @Test
  void test_addMultipleReviewers(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "reviewers");

    EntityReference reviewer1 = testUser1().getEntityReference();
    EntityReference reviewer2 = testUser2().getEntityReference();
    fetched.setReviewers(List.of(reviewer1, reviewer2));

    Glossary updated = patchEntity(fetched.getId().toString(), fetched);

    Glossary verify = client.glossaries().get(updated.getId().toString(), "reviewers");
    assertNotNull(verify.getReviewers());
    assertEquals(2, verify.getReviewers().size());
  }

  @Test
  void test_patchAddDeleteReviewers(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "reviewers");
    EntityReference reviewer1 = testUser1().getEntityReference();
    fetched.setReviewers(List.of(reviewer1));

    Glossary updated = patchEntity(fetched.getId().toString(), fetched);
    assertEquals(0.2, updated.getVersion(), 0.001);

    Glossary verify = client.glossaries().get(updated.getId().toString(), "reviewers");
    assertNotNull(verify.getReviewers());
    assertEquals(1, verify.getReviewers().size());

    EntityReference reviewer2 = testUser2().getEntityReference();
    verify.setReviewers(List.of(reviewer1, reviewer2));
    updated = patchEntity(verify.getId().toString(), verify);

    verify = client.glossaries().get(updated.getId().toString(), "reviewers");
    assertEquals(2, verify.getReviewers().size());

    verify.setReviewers(List.of(reviewer2));
    updated = patchEntity(verify.getId().toString(), verify);

    verify = client.glossaries().get(updated.getId().toString(), "reviewers");
    assertEquals(1, verify.getReviewers().size());
    assertEquals(reviewer2.getId(), verify.getReviewers().get(0).getId());
  }

  @Test
  void test_updateGlossaryMutuallyExclusiveRemainsSame(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("mutuallyExclusiveGlossary"))
            .withMutuallyExclusive(true)
            .withDescription("Test mutually exclusive immutability");

    Glossary glossary = createEntity(create);
    assertTrue(glossary.getMutuallyExclusive());

    glossary.setMutuallyExclusive(false);
    Glossary updated = patchEntity(glossary.getId().toString(), glossary);

    assertTrue(updated.getMutuallyExclusive());
  }

  @Test
  void test_glossaryWithDomain(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    EntityReference domainRef = testDomain().getEntityReference();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("glossaryWithDomain"))
            .withDomains(List.of(domainRef.getFullyQualifiedName()))
            .withDescription("Glossary with domain");

    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "domains");
    assertNotNull(fetched.getDomains());
    assertFalse(fetched.getDomains().isEmpty());
    assertEquals(domainRef.getId(), fetched.getDomains().get(0).getId());
  }

  @Test
  void test_glossaryWithTagsAndOwner(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    EntityReference ownerRef = testUser1().getEntityReference();
    List<TagLabel> tags = List.of(personalDataTagLabel());

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("glossaryWithTagsOwner"))
            .withOwners(List.of(ownerRef))
            .withTags(tags)
            .withDescription("Glossary with tags and owner");

    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "owners,tags");
    assertNotNull(fetched.getOwners());
    assertNotNull(fetched.getTags());
    assertFalse(fetched.getOwners().isEmpty());
    assertFalse(fetched.getTags().isEmpty());
  }

  @Test
  void test_deleteGlossaryWithTerms(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary createGlossary = createMinimalRequest(ns);
    Glossary glossary = createEntity(createGlossary);

    org.openmetadata.schema.api.data.CreateGlossaryTerm createTerm =
        new org.openmetadata.schema.api.data.CreateGlossaryTerm()
            .withName(ns.prefix("term1"))
            .withGlossary(glossary.getFullyQualifiedName())
            .withDescription("Test term");
    client.glossaryTerms().create(createTerm);

    assertThrows(
        Exception.class,
        () -> deleteEntity(glossary.getId().toString()),
        "Cannot delete glossary with terms without recursive flag");

    hardDeleteEntity(glossary.getId().toString());

    assertThrows(
        Exception.class,
        () -> getEntity(glossary.getId().toString()),
        "Glossary should be hard deleted");
  }

  @Test
  void test_renameGlossarySystemProvider(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("systemGlossary"))
            .withProvider(org.openmetadata.schema.type.ProviderType.SYSTEM)
            .withDescription("System glossary");

    Glossary glossary = createEntity(create);

    glossary.setName(ns.prefix("renamedSystemGlossary"));

    assertThrows(
        Exception.class,
        () -> patchEntity(glossary.getId().toString(), glossary),
        "Cannot rename system provider glossary");
  }

  @Test
  void test_listGlossariesWithFields(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    EntityReference ownerRef = testUser1().getEntityReference();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("listGlossaryFields"))
            .withOwners(List.of(ownerRef))
            .withDescription("Glossary for listing with fields");
    createEntity(create);

    org.openmetadata.sdk.models.ListParams params = new org.openmetadata.sdk.models.ListParams();
    params.setFields("owners,tags");
    params.setLimit(100);

    org.openmetadata.sdk.models.ListResponse<Glossary> response = listEntities(params);

    assertNotNull(response);
    assertNotNull(response.getData());
  }

  @Test
  void test_glossaryTermCount(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary createGlossary = createMinimalRequest(ns);
    Glossary glossary = createEntity(createGlossary);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "termCount");
    assertEquals(0, fetched.getTermCount());

    org.openmetadata.schema.api.data.CreateGlossaryTerm createTerm1 =
        new org.openmetadata.schema.api.data.CreateGlossaryTerm()
            .withName(ns.prefix("termForCount1"))
            .withGlossary(glossary.getFullyQualifiedName())
            .withDescription("Test term 1");
    client.glossaryTerms().create(createTerm1);

    org.openmetadata.schema.api.data.CreateGlossaryTerm createTerm2 =
        new org.openmetadata.schema.api.data.CreateGlossaryTerm()
            .withName(ns.prefix("termForCount2"))
            .withGlossary(glossary.getFullyQualifiedName())
            .withDescription("Test term 2");
    client.glossaryTerms().create(createTerm2);

    fetched = client.glossaries().get(glossary.getId().toString(), "termCount");
    assertTrue(fetched.getTermCount() >= 2);
  }

  @Test
  void test_glossaryUsageCount(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary createGlossary = createMinimalRequest(ns);
    Glossary glossary = createEntity(createGlossary);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "usageCount");
    assertNotNull(fetched);
  }

  @Test
  void test_updateGlossaryTags(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "tags");

    List<TagLabel> tags = List.of(personalDataTagLabel());
    fetched.setTags(tags);

    Glossary updated = patchEntity(fetched.getId().toString(), fetched);

    Glossary verify = client.glossaries().get(updated.getId().toString(), "tags");
    assertNotNull(verify.getTags());
    assertFalse(verify.getTags().isEmpty());
  }

  @Test
  void test_glossaryPagination(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    for (int i = 0; i < 5; i++) {
      CreateGlossary create =
          new CreateGlossary()
              .withName(ns.prefix("paginationGlossary" + i))
              .withDescription("Glossary for pagination test " + i);
      createEntity(create);
    }

    org.openmetadata.sdk.models.ListParams params = new org.openmetadata.sdk.models.ListParams();
    params.setLimit(2);

    org.openmetadata.sdk.models.ListResponse<Glossary> firstPage = listEntities(params);
    assertNotNull(firstPage);
    assertEquals(2, firstPage.getData().size());

    if (firstPage.getPaging() != null && firstPage.getPaging().getAfter() != null) {
      params.setAfter(firstPage.getPaging().getAfter());
      org.openmetadata.sdk.models.ListResponse<Glossary> secondPage = listEntities(params);
      assertNotNull(secondPage);
    }
  }

  @Test
  void test_glossaryFieldValidation(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create =
        new CreateGlossary().withName(ns.prefix("validationGlossary")).withDescription("");

    Glossary glossary = createEntity(create);
    assertNotNull(glossary);
    assertEquals(ns.prefix("validationGlossary"), glossary.getName());
  }

  @Test
  void test_glossaryWithEmptyReviewers(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("emptyReviewersGlossary"))
            .withReviewers(List.of())
            .withDescription("Glossary with empty reviewers list");

    Glossary glossary = createEntity(create);
    assertNotNull(glossary);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "reviewers");
    if (fetched.getReviewers() != null) {
      assertTrue(fetched.getReviewers().isEmpty());
    }
  }

  @Test
  void test_updateGlossaryOwner(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "owners");

    EntityReference ownerRef = testUser1().getEntityReference();
    fetched.setOwners(List.of(ownerRef));

    Glossary updated = patchEntity(fetched.getId().toString(), fetched);

    Glossary verify = client.glossaries().get(updated.getId().toString(), "owners");
    assertNotNull(verify.getOwners());
    assertEquals(1, verify.getOwners().size());
    assertEquals(ownerRef.getId(), verify.getOwners().get(0).getId());

    EntityReference newOwner = testUser2().getEntityReference();
    verify.setOwners(List.of(newOwner));
    updated = patchEntity(verify.getId().toString(), verify);

    verify = client.glossaries().get(updated.getId().toString(), "owners");
    assertEquals(1, verify.getOwners().size());
    assertEquals(newOwner.getId(), verify.getOwners().get(0).getId());
  }

  @Test
  void test_glossaryVersionIncrement(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);
    assertEquals(0.1, glossary.getVersion(), 0.001);

    Glossary fetched = client.glossaries().get(glossary.getId().toString());
    fetched.setDescription("Updated description for version test");
    Glossary updated = patchEntity(fetched.getId().toString(), fetched);
    assertEquals(0.2, updated.getVersion(), 0.001);

    // displayName update may or may not increment version depending on implementation
    fetched = client.glossaries().get(updated.getId().toString());
    fetched.setDisplayName("Updated Display Name");
    updated = patchEntity(fetched.getId().toString(), fetched);
    assertTrue(
        updated.getVersion() >= 0.2, "Version should be at least 0.2 after displayName update");
  }

  @Test
  void test_getGlossaryVersions(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);

    Glossary fetched = client.glossaries().get(glossary.getId().toString());
    fetched.setDescription("Version 2 update");
    patchEntity(fetched.getId().toString(), fetched);

    fetched = client.glossaries().get(glossary.getId().toString());
    fetched.setDescription("Version 3 update");
    patchEntity(fetched.getId().toString(), fetched);

    var versionHistory = client.glossaries().getVersionList(glossary.getId());
    assertNotNull(versionHistory);
    assertNotNull(versionHistory.getVersions());
    // Version history should have at least 2 versions (creation + 1 update)
    assertTrue(
        versionHistory.getVersions().size() >= 2, "Should have at least 2 versions in history");
  }

  @Test
  void test_getGlossarySpecificVersion(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create = createMinimalRequest(ns);
    Glossary glossary = createEntity(create);
    String originalDescription = glossary.getDescription();

    Glossary fetched = client.glossaries().get(glossary.getId().toString());
    fetched.setDescription("Updated to version 2");
    Glossary v2 = patchEntity(fetched.getId().toString(), fetched);

    Glossary version1 = client.glossaries().getVersion(glossary.getId().toString(), 0.1);
    assertEquals(0.1, version1.getVersion(), 0.001);
    assertEquals(originalDescription, version1.getDescription());

    Glossary version2 = client.glossaries().getVersion(glossary.getId().toString(), 0.2);
    assertEquals(0.2, version2.getVersion(), 0.001);
    assertEquals("Updated to version 2", version2.getDescription());
  }

  @Test
  void test_glossaryDisplayNameUpdate(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("displayNameGlossary"))
            .withDisplayName("Original Display Name")
            .withDescription("Test display name");

    Glossary glossary = createEntity(create);
    assertEquals("Original Display Name", glossary.getDisplayName());

    glossary.setDisplayName("Updated Display Name");
    Glossary updated = patchEntity(glossary.getId().toString(), glossary);
    assertEquals("Updated Display Name", updated.getDisplayName());
  }

  @Test
  void test_glossaryWithAllFields(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    EntityReference ownerRef = testUser1().getEntityReference();
    EntityReference reviewerRef = testUser2().getEntityReference();
    List<TagLabel> tags = List.of(personalDataTagLabel());

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("allFieldsGlossary"))
            .withDisplayName("All Fields Glossary")
            .withDescription("Glossary with all possible fields")
            .withOwners(List.of(ownerRef))
            .withReviewers(List.of(reviewerRef))
            .withTags(tags)
            .withMutuallyExclusive(true);

    Glossary glossary = createEntity(create);

    Glossary fetched =
        client.glossaries().get(glossary.getId().toString(), "owners,reviewers,tags");
    assertEquals("All Fields Glossary", fetched.getDisplayName());
    assertTrue(fetched.getMutuallyExclusive());
    assertNotNull(fetched.getOwners());
    assertNotNull(fetched.getReviewers());
    assertNotNull(fetched.getTags());
  }

  // ===================================================================
  // CSV IMPORT VERSIONING TESTS
  // ===================================================================

  /**
   * Test: Bulk CSV import of glossary terms increments the glossary version
   * and creates proper version history with bulk import change description.
   *
   * This test validates the implementation that adds versioning support
   * for bulk import operations for both sync and async endpoints.
   */
  @Test
  void test_bulkImportGlossaryTermsIncrementsVersion(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Step 1: Create a glossary with initial version 0.1
    CreateGlossary createGlossary = createMinimalRequest(ns);
    Glossary glossary = createEntity(createGlossary);
    assertEquals(0.1, glossary.getVersion(), 0.001, "Initial version should be 0.1");

    // Step 2: Prepare CSV content with multiple glossary terms
    String csvContent = buildGlossaryTermsCsv(glossary.getFullyQualifiedName(), ns);

    // Step 3: Import CSV using SYNC method (now also creates version history!)
    try {
      String result =
          client.glossaries().importCsv(glossary.getFullyQualifiedName(), csvContent, false);
      assertNotNull(result, "Import should return result");
      // Result is a JSON string of CsvImportResult
    } catch (Exception e) {
      fail("CSV import failed: " + e.getMessage());
    }

    // Step 4: Verify version incremented to 0.2
    Glossary updatedGlossary = client.glossaries().get(glossary.getId().toString());
    assertEquals(
        0.2,
        updatedGlossary.getVersion(),
        0.001,
        "Glossary version should increment to 0.2 after bulk import");

    // Step 5: Retrieve version history
    EntityHistory versionHistory = client.glossaries().getVersionList(glossary.getId());
    assertNotNull(versionHistory, "Version history should exist");
    assertNotNull(versionHistory.getVersions(), "Version list should exist");
    assertTrue(
        versionHistory.getVersions().size() >= 2, "Should have at least 2 versions (0.1 and 0.2)");

    // Step 6: Get version 0.2 and verify it has change description
    Glossary version0_2 = client.glossaries().getVersion(glossary.getId().toString(), 0.2);
    assertNotNull(version0_2, "Version 0.2 should exist");
    assertNotNull(version0_2.getChangeDescription(), "Version 0.2 should have change description");

    // Step 7: Verify change description contains 'bulkImport' field change
    boolean hasBulkImportChange =
        version0_2.getChangeDescription().getFieldsUpdated().stream()
            .anyMatch(fc -> "bulkImport".equals(fc.getName()));
    assertTrue(hasBulkImportChange, "Change description should contain 'bulkImport' field change");

    // Step 8: Verify bulkImport field has statistics
    FieldChange bulkImportField =
        version0_2.getChangeDescription().getFieldsUpdated().stream()
            .filter(fc -> "bulkImport".equals(fc.getName()))
            .findFirst()
            .orElse(null);
    assertNotNull(bulkImportField, "bulkImport field change should exist");
    assertNotNull(
        bulkImportField.getNewValue(),
        "bulkImport field should contain import statistics (CsvImportResult)");

    // Step 9: Verify glossary terms were actually created
    try {
      // Get all glossary terms and filter by glossary
      List<org.openmetadata.schema.entity.data.GlossaryTerm> allTerms =
          client.glossaryTerms().list().getData();

      // Filter terms belonging to this glossary
      List<org.openmetadata.schema.entity.data.GlossaryTerm> terms =
          allTerms.stream()
              .filter(
                  t -> t.getGlossary() != null && glossary.getId().equals(t.getGlossary().getId()))
              .toList();

      assertNotNull(terms, "Glossary terms should be returned");
      assertEquals(3, terms.size(), "Should have imported 3 glossary terms");
    } catch (Exception e) {
      fail("Failed to verify imported glossary terms: " + e.getMessage());
    }
  }

  /**
   * Helper method to create CSV content for glossary terms import.
   * Returns CSV with header and 3 glossary terms with all required columns.
   *
   * CSV Format (14 columns):
   * parent,name*,displayName,description,synonyms,relatedTerms,references,tags,
   * reviewers,owner,glossaryStatus,color,iconURL,extension
   *
   * Note: parent column is for PARENT GLOSSARY TERM, not glossary.
   * For top-level terms, leave parent EMPTY.
   *
   * @param glossaryFqn Fully qualified name of the parent glossary (not used in CSV)
   * @param ns Test namespace for unique naming
   * @return CSV string ready for import
   */
  private String buildGlossaryTermsCsv(String glossaryFqn, TestNamespace ns) {
    StringBuilder csv = new StringBuilder();
    // CSV header with all 14 columns as expected by GlossaryCsv.addRecord()
    // Note: 'owner' (singular) NOT 'owners', and 'glossaryStatus' NOT 'status'
    csv.append(
        "parent,name*,displayName,description,synonyms,relatedTerms,references,tags,reviewers,owner,glossaryStatus,color,iconURL,extension\n");

    // Add 3 top-level glossary terms with EMPTY parent column
    // Columns: parent, name, displayName, description, synonyms, relatedTerms, references,
    //          tags, reviewers, owner, glossaryStatus, color, iconURL, extension
    csv.append(
        String.format(
            ",\"%s\",\"Term 1\",\"First test term for bulk import\",,,,,,,,,,\n",
            ns.prefix("bulkTerm1")));
    csv.append(
        String.format(
            ",\"%s\",\"Term 2\",\"Second test term for bulk import\",,,,,,,,,,\n",
            ns.prefix("bulkTerm2")));
    csv.append(
        String.format(
            ",\"%s\",\"Term 3\",\"Third test term for bulk import\",,,,,,,,,,\n",
            ns.prefix("bulkTerm3")));

    return csv.toString();
  }

  // ===================================================================
  // VERSION HISTORY SUPPORT
  // ===================================================================

  @Override
  protected EntityHistory getVersionHistory(UUID id) {
    return SdkClients.adminClient().glossaries().getVersionList(id);
  }

  @Override
  protected Glossary getVersion(UUID id, Double version) {
    return SdkClients.adminClient().glossaries().getVersion(id.toString(), version);
  }

  @Override
  protected org.openmetadata.sdk.services.EntityServiceBase<Glossary> getEntityService() {
    return SdkClients.adminClient().glossaries();
  }

  @Override
  protected String getImportExportContainerName(TestNamespace ns) {
    if (lastCreatedGlossary == null) {
      CreateGlossary request = createMinimalRequest(ns);
      request.setName(ns.prefix("export_glossary"));
      lastCreatedGlossary = createEntity(request);
    }
    return lastCreatedGlossary.getFullyQualifiedName();
  }

  // ===================================================================
  // RENAME CONSOLIDATION TESTS
  // These tests verify that child entities (glossary terms) are preserved
  // when a glossary is renamed and then other fields are updated within
  // the same session (which triggers change consolidation).
  // ===================================================================

  /**
   * Test that glossary terms are preserved when a glossary is renamed and then the description is
   * updated. This tests the consolidation logic to ensure it doesn't revert to a previous version
   * with the old FQN.
   */
  @Test
  void test_renameAndUpdateDescriptionPreservesTerms(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    // Create a glossary with terms
    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("glossary_rename_consolidate"))
            .withDescription("Initial description");
    Glossary glossary = createEntity(create);

    // Add a glossary term
    org.openmetadata.schema.api.data.CreateGlossaryTerm createTerm =
        new org.openmetadata.schema.api.data.CreateGlossaryTerm()
            .withName(ns.prefix("term_for_rename"))
            .withGlossary(glossary.getFullyQualifiedName())
            .withDescription("Test term");
    org.openmetadata.schema.entity.data.GlossaryTerm term =
        client.glossaryTerms().create(createTerm);

    // Verify term count before rename
    Glossary beforeRename = client.glossaries().get(glossary.getId().toString(), "termCount");
    assertTrue(beforeRename.getTermCount() >= 1, "Should have at least 1 term before rename");

    // Rename the glossary
    String newName = "renamed-" + glossary.getName();
    glossary.setName(newName);
    Glossary renamed = patchEntity(glossary.getId().toString(), glossary);
    assertEquals(newName, renamed.getName());

    // Verify terms after rename
    Glossary afterRename = client.glossaries().get(renamed.getId().toString(), "termCount");
    assertTrue(afterRename.getTermCount() >= 1, "Should have at least 1 term after rename");

    // Update description (triggers consolidation logic)
    renamed.setDescription("Updated description after rename");
    Glossary afterDescUpdate = patchEntity(renamed.getId().toString(), renamed);
    assertEquals("Updated description after rename", afterDescUpdate.getDescription());

    // Verify terms are preserved after consolidation
    Glossary afterConsolidation =
        client.glossaries().get(afterDescUpdate.getId().toString(), "termCount");
    assertTrue(
        afterConsolidation.getTermCount() >= 1,
        "CRITICAL: Terms should be preserved after rename + description update consolidation");

    // Verify the term's glossary reference has the updated FQN
    org.openmetadata.schema.entity.data.GlossaryTerm updatedTerm =
        client.glossaryTerms().get(term.getId().toString(), "glossary");
    assertEquals(
        afterDescUpdate.getFullyQualifiedName(),
        updatedTerm.getGlossary().getFullyQualifiedName(),
        "Term's glossary reference should have updated FQN after consolidation");
  }

  /**
   * Test multiple renames followed by updates within the same session. This is a more complex
   * scenario that tests the robustness of the consolidation fix.
   */
  @Test
  void test_multipleRenamesWithUpdatesPreservesTerms(TestNamespace ns) {
    OpenMetadataClient client = SdkClients.adminClient();

    CreateGlossary create =
        new CreateGlossary()
            .withName(ns.prefix("glossary_multi_rename"))
            .withDescription("Initial description");
    Glossary glossary = createEntity(create);

    // Add a glossary term
    org.openmetadata.schema.api.data.CreateGlossaryTerm createTerm =
        new org.openmetadata.schema.api.data.CreateGlossaryTerm()
            .withName(ns.prefix("term_multi_rename"))
            .withGlossary(glossary.getFullyQualifiedName())
            .withDescription("Test term");
    org.openmetadata.schema.entity.data.GlossaryTerm term =
        client.glossaryTerms().create(createTerm);

    Glossary fetched = client.glossaries().get(glossary.getId().toString(), "termCount");
    assertTrue(fetched.getTermCount() >= 1);

    String[] names = {"renamed-first", "renamed-second", "renamed-third"};

    for (int i = 0; i < names.length; i++) {
      String newName = names[i] + "-" + UUID.randomUUID().toString().substring(0, 8);

      glossary.setName(newName);
      glossary = patchEntity(glossary.getId().toString(), glossary);
      assertEquals(newName, glossary.getName());

      fetched = client.glossaries().get(glossary.getId().toString(), "termCount");
      assertTrue(fetched.getTermCount() >= 1, "Terms should be preserved after rename " + (i + 1));

      glossary.setDescription("Description after rename " + (i + 1));
      glossary = patchEntity(glossary.getId().toString(), glossary);

      fetched = client.glossaries().get(glossary.getId().toString(), "termCount");
      assertTrue(
          fetched.getTermCount() >= 1,
          "Terms should be preserved after rename + update iteration " + (i + 1));
    }

    // Verify the term's glossary reference has the final updated FQN
    org.openmetadata.schema.entity.data.GlossaryTerm updatedTerm =
        client.glossaryTerms().get(term.getId().toString(), "glossary");
    assertEquals(
        glossary.getFullyQualifiedName(),
        updatedTerm.getGlossary().getFullyQualifiedName(),
        "Term's glossary reference should have final updated FQN");
  }

  /**
   * Get CSV headers for glossary term import/export.
   * Uses GlossaryRepository.GlossaryCsv to get proper headers.
   */
  private List<org.openmetadata.schema.type.csv.CsvHeader> getGlossaryCsvHeaders(
      Glossary glossary, boolean recursive) {
    return GlossaryRepository.GlossaryCsv.HEADERS;
  }

  @Test
  void test_csvImportCreate(TestNamespace ns) throws Exception {
    CreateGlossary createGlossary = createRequest(ns.prefix("csv-import-create"), ns);
    Glossary glossary = createEntity(createGlossary);

    // Create CSV records for initial import (these should be marked as ENTITY_CREATED)
    // Headers:
    // parent,name,displayName,description,owner,tags,glossaryTerms,tiers,certification,retentionPeriod,sourceUrl,domains,extension
    List<String> createRecords =
        listOf(
            "," + ns.prefix("term1") + ",Display Term 1,Description for term1,,,,,,,,,,",
            "," + ns.prefix("term2") + ",Display Term 2,Description for term2,,,,,,,,,,");

    String csv = createCsv(getGlossaryCsvHeaders(glossary, false), createRecords, null);

    // Import CSV and verify all records are marked as created
    CsvImportResult result = importCsv(glossary.getName(), csv, false);
    assertSummary(result, ApiStatus.SUCCESS, 3, 3, 0); // 3 = header + 2 records

    // Verify the result contains "Entity created" status for all records
    String[] resultLines = result.getImportResultsCsv().split(CsvUtil.LINE_SEPARATOR);
    for (int i = 1; i < resultLines.length; i++) { // Skip header
      assertTrue(
          resultLines[i].contains(EntityCsv.ENTITY_CREATED),
          "Record " + i + " should be marked as created: " + resultLines[i]);
      // Verify changeDescription is present
      assertTrue(
          resultLines[i].contains("fieldsAdded"),
          "Record " + i + " should have changeDescription: " + resultLines[i]);
    }
  }

  @Test
  void test_csvImportUpdate(TestNamespace ns) throws Exception {
    CreateGlossary createGlossary = createRequest(ns.prefix("csv-import-update"), ns);
    Glossary glossary = createEntity(createGlossary);

    // Create glossary terms using SDK directly
    OpenMetadataClient client = SdkClients.adminClient();
    org.openmetadata.schema.api.data.CreateGlossaryTerm createTerm1 =
        new org.openmetadata.schema.api.data.CreateGlossaryTerm()
            .withName(ns.prefix("term1"))
            .withGlossary(glossary.getFullyQualifiedName())
            .withDescription("Initial description 1");
    client.glossaryTerms().create(createTerm1);

    org.openmetadata.schema.api.data.CreateGlossaryTerm createTerm2 =
        new org.openmetadata.schema.api.data.CreateGlossaryTerm()
            .withName(ns.prefix("term2"))
            .withGlossary(glossary.getFullyQualifiedName())
            .withDescription("Initial description 2");
    client.glossaryTerms().create(createTerm2);

    // First, create the terms via CSV import to establish baseline
    // Headers:
    // parent,name,displayName,description,owner,tags,glossaryTerms,tiers,certification,retentionPeriod,sourceUrl,domains,extension
    List<String> createRecords =
        listOf(
            "," + ns.prefix("term1") + ",Display Term 1,Initial description 1,,,,,,,,,,",
            "," + ns.prefix("term2") + ",Display Term 2,Initial description 2,,,,,,,,,,");

    String createCsv = createCsv(getGlossaryCsvHeaders(glossary, false), createRecords, null);
    importCsv(glossary.getName(), createCsv, false);

    // Now update the same terms (these should be marked as ENTITY_UPDATED)
    List<String> updateRecords =
        listOf(
            "," + ns.prefix("term1") + ",Updated Display 1,Updated description 1,,,,,,,,,,",
            "," + ns.prefix("term2") + ",Updated Display 2,Updated description 2,,,,,,,,,,");

    String updateCsv = createCsv(getGlossaryCsvHeaders(glossary, false), updateRecords, null);

    // Import updated CSV and verify all records are marked as updated
    CsvImportResult result = importCsv(glossary.getName(), updateCsv, false);
    assertSummary(result, ApiStatus.SUCCESS, 3, 3, 0); // 3 = header + 2 records

    // Verify the result contains "Entity updated" status for all records
    String[] resultLines = result.getImportResultsCsv().split(CsvUtil.LINE_SEPARATOR);
    for (int i = 1; i < resultLines.length; i++) { // Skip header
      assertTrue(
          resultLines[i].contains(EntityCsv.ENTITY_UPDATED),
          "Record " + i + " should be marked as updated: " + resultLines[i]);
      // Verify changeDescription is present and contains fieldsUpdated
      assertTrue(
          resultLines[i].contains("fieldsUpdated"),
          "Record " + i + " should have fieldsUpdated in changeDescription: " + resultLines[i]);
    }
  }
}
