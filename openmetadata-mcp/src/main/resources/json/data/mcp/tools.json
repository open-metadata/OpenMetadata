{
  "tools": [
    {
      "name": "search_metadata",
      "description": "Find data assets and business terms in OpenMetadata catalog. Searches tables, dashboards, topics, pipelines, and other metadata entities using natural language.",
      "parameters": {
        "description": "Use 'query' parameter for natural language search (recommended for most use cases). The system will automatically optimize the search query.",
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "Natural language search query. Use this for simple searches. Examples: 'tables owned by marketing', 'dashboards with customer data', 'tier1 tables', 'tables with column SKU', 'BigQuery services'. The query will be automatically converted to an optimized search."
          },
          "entityType": {
            "type": "string",
            "description": "Filter by entity type (auto-detected if not specified). Use singular form: table, dashboard, topic, pipeline, database, databaseService, glossary, glossaryTerm, mlmodel, container, chart, metric, user, team, domain, dataProduct."
          },
          "queryFilter": {
            "type": "string",
            "description": "Advanced: Direct OpenSearch JSON query string for precise control. Only use if you can generate valid OpenSearch DSL. When provided, this overrides the 'query' parameter. Must include entityType filter. Example: '{\"bool\": {\"must\": [{\"term\": {\"entityType\": \"table\"}}, {\"term\": {\"owners.name\": \"marketing\"}}]}}'. Key rules: Use singular entityType, 'owners.name' (plural), tier format is 'Tier.Tier1', columns are NOT nested."
          },
          "from": {
            "type": "integer",
            "description": "In case the request more than 'size' results, this is the offset from the first result you want to fetch. Default is 0.",
            "default": 10
          },
          "size": {
            "type": "integer",
            "description": "Number of results to return. Default is 10, we can iteratively page through results by increasing 'from'. Maximum allowed is 50.",
            "default": 10
          },
          "includeDeleted": {
            "type": "boolean",
            "description": "Include deleted entities in search results. Default is false.",
            "default": false
          },
          "fields": {
            "type": "string",
            "description": "Comma-separated additional fields to include. Default returns: name, displayName, fullyQualifiedName, description, entityType, service, database, databaseSchema, serviceType, href, tags, owners, tier, tableType, columnNames.\n\nAdditional fields by entity type:\n- Table entities: columns, schemaDefinition, queries, upstreamLineage, entityRelationship\n- Topic entities: messageSchema, partitions, replicationFactor  \n- Dashboard entities: charts, dataModels, project\n- Pipeline entities: tasks, pipelineUrl, scheduleInterval\n- All entities: createdAt, updatedAt, changeDescription, extension, domain, dataProducts, lifeCycle, sourceHash\n\nExample: 'columns,queries' for table column details and sample queries."
          },
          "includeAggregations": {
            "type": "boolean",
            "description": "Whether to include aggregation data (facets) in the response. Defaults to false to optimize LLM context size. Set to true only when you need aggregation statistics like counts by service type, owner, tags, etc. Aggregations can significantly increase response size.",
            "default": false
          },
          "maxAggregationBuckets": {
            "type": "integer",
            "description": "Maximum number of aggregation buckets to return per field when includeAggregations is true. Limits response size to prevent context overflow. Default is 10, maximum allowed is 50.",
            "default": 10
          }
        },
        "required": [],
        "examples": [
          {
            "description": "Simple search - Find tables owned by a team",
            "query": "tables owned by marketing",
            "entityType": "table"
          },
          {
            "description": "Simple search - Find customer-related data",
            "query": "tables with customer data"
          },
          {
            "description": "Simple search - Find tier1 tables",
            "query": "tier1 tables",
            "entityType": "table"
          },
          {
            "description": "Simple search - Find dashboards",
            "query": "sales dashboards",
            "entityType": "dashboard"
          },
          {
            "description": "Simple search with pagination",
            "query": "tables",
            "size": 20,
            "from": 0
          },
          {
            "description": "Advanced - Owner filter with OpenSearch",
            "queryFilter": "{\"bool\": {\"must\": [{\"term\": {\"entityType\": \"table\"}}, {\"term\": {\"owners.name\": \"marketing\"}}]}}"
          },
          {
            "description": "Advanced - Column search with OpenSearch",
            "queryFilter": "{\"bool\": {\"must\": [{\"term\": {\"entityType\": \"table\"}}, {\"match\": {\"columns.name\": \"customer\"}}]}}"
          },
          {
            "description": "Advanced - Tier1 tables with OpenSearch",
            "queryFilter": "{\"bool\": {\"must\": [{\"term\": {\"entityType\": \"table\"}}, {\"term\": {\"tier.tagFQN\": \"Tier.Tier1\"}}]}}"
          },
          {
            "description": "Advanced - Tag filtering with OpenSearch",
            "queryFilter": "{\"bool\": {\"must\": [{\"term\": {\"entityType\": \"table\"}}, {\"term\": {\"tags.tagFQN\": \"PII.Sensitive\"}}]}}"
          },
          {
            "description": "Advanced - Aggregation query for counting",
            "queryFilter": "{\"size\": 0, \"query\": {\"bool\": {\"must\": [{\"term\": {\"entityType\": \"databaseService\"}}, {\"term\": {\"serviceType\": \"BigQuery\"}}]}}, \"aggs\": {\"total_count\": {\"value_count\": {\"field\": \"_id\"}}}}"
          }
        ]
      }
    },
    {
      "name": "get_entity_details",
      "description": "Get detailed information about a specific entity. Response is optimized for LLM context by excluding verbose metadata fields.",
      "parameters": {
        "description": "Fqn is the fully qualified name of the entity. Entity type could be table, topic etc.",
        "type": "object",
        "properties": {
          "entityType": {
            "type": "string",
            "description": "Type of entity"
          },
          "fqn": {
            "type": "string",
            "description": "Fully qualified name of the entity"
          }
        },
        "required": [
          "entityType",
          "fqn"
        ]
      }
    },
    {
      "name": "create_glossary_term",
      "description": "Creates a new Glossary Term. Note that a glossary term must be part of a Glossary, so the glossary must be specified in the parameters. If you can't find the right glossary to use, respond back to the user to create a new Glossary first. Note that you can help the user to create the Glossary as well. If you don't find any Glossary that could be related, please list to the user the available Glossaries so users can choose if they want to create or reuse something. Also, note that glossary terms can be hierarchical: for example, a glossary term 'Accounts' can have a child term 'Credit Account', 'Savings Account', etc. So if you find any terms that can be related, it might make sense to create a new term as a child of an existing term.",
      "parameters": {
        "type": "object",
        "properties": {
          "glossary": {
            "type": "string",
            "description": "Glossary in which the term belongs. This should be its fully qualified name."
          },
          "parentTerm": {
            "type": "string",
            "description": "Optional parent term for the new term. This should be its fully qualified name defined as <glossary>.<term>. If the Glossary Term has other parents, the Fully Qualified Name will be <glossary>.<parent>...<term>. If not provided, the term will be created at the root level of the glossary."
          },
          "name": {
            "type": "string",
            "description": "Glossary Term name."
          },
          "description": {
            "type": "string",
            "description": "Glossary Term description."
          },
          "owners": {
            "type": "array",
            "description": "Glossary Term owner. This could be an OpenMetadata User or Team. If you don't know who the owner is, you can leave this empty, but let the user know that they can add owners later.",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "glossary",
          "name",
          "description"
        ]
      }
    },
    {
      "name": "create_glossary",
      "description": "Creates a new Glossary. A Glossary is a collection of terms that are used to define the business vocabulary of an organization. Typically, similar terms are grouped together in a Glossary. For example, a Glossary names 'Marketing' could contain terms like 'Campaign', 'Lead', 'Opportunity', etc.",
      "parameters": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "Glossary Term name."
          },
          "description": {
            "type": "string",
            "description": "Glossary Term description."
          },
          "owners": {
            "type": "array",
            "description": "Glossary Term owner. This could be an OpenMetadata User or Team. If you don't know who the owner is, you can leave this empty, but let the user know that they can add owners later.",
            "items": {
              "type": "string"
            }
          },
          "reviewers": {
            "type": "array",
            "description": "Glossary Term owner. This could be an OpenMetadata User or Team. If you don't know who the owner is, you can leave this empty, but let the user know that they can add owners later.",
            "items": {
              "type": "string"
            }
          },
          "mutuallyExclusive": {
            "type": "boolean",
            "description": "Glossary terms that are direct children in this glossary are mutually exclusive. When mutually exclusive is `true` only one term can be used to tag an entity. When mutually exclusive is `false`, multiple terms from this group can be used to tag an entity. This is an important setting. If you are not sure, ask the user to clarify. If the user doesn't know, set it to `false`.",
            "default": false
          }
        },
        "required": [
          "name",
          "description",
          "mutuallyExclusive"
        ]
      }
    },
    {
      "name": "patch_entity",
      "description": "Patches an Entity based on a JSONPatch. Beforehand the Entity should be validated by finding it and creating a proper patch.",
      "parameters": {
        "type": "object",
        "properties": {
          "entityType": {
            "type": "string",
            "description": "Entity Type to patch."
          },
          "fqn": {
            "type": "string",
            "description": "Fully Qualified Name of the Entity to be patched."
          },
          "patch": {
            "type": "string",
            "description": "JSONPatch as String format."
          }
        },
        "required": [
          "entityType",
          "fqn",
          "patch"
        ]
      }
    },
    {
      "name": "get_entity_lineage",
      "description": "Get detailed information about lineage (upstream/downstream dependencies) of a specific entity. Use this for root cause (upstream entities) or impact (downstream entities) analysis and explaining dependencies between entities.",
      "parameters": {
        "description": "Fqn is the fully qualified name of the entity. Entity type could be table, topic etc.",
        "type": "object",
        "properties": {
          "entityType": {
            "type": "string",
            "description": "Type of entity"
          },
          "fqn": {
            "type": "string",
            "description": "Fully qualified name of the entity"
          },
          "upstreamDepth": {
            "type": "integer",
            "description": "Number of upstream hops to traverse. Default is 3, maximum is 10 to prevent excessive response size.",
            "default": 3
          },
          "downstreamDepth": {
            "type": "integer",
            "description": "Number of downstream hops to traverse. Default is 3, maximum is 10 to prevent excessive response size.",
            "default": 3
          }
        },
        "required": [
          "entityType",
          "fqn"
        ]
      }
    }
  ]
}